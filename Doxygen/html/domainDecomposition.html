<!-- HTML header for doxygen 1.8.11-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<title>OpenFOAM: Domain decomposition</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="OpenFOAMlogo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname"><a href="http://openfoam.com">OpenFOAM</a>
   &#160;<span id="projectnumber"><a href="http://openfoam.com/download/source">v2306</a></span>
   </div>
   <div id="projectbrief"><a href="https://develop.openfoam.com">The open source CFD toolbox</a></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Domain decomposition</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="secIntroduction"></a>
Introduction</h1>
<p>When running a simulation in parallel, the geometry must first be decomposed (segmented) into individual geometries for each MPI process. These separate geometries are <em>connected</em> together with special processor boundary patches. The processor-specific <code>constant/polyMesh/boundary</code> files will contain this type of entry:</p>
<pre class="fragment">    procBoundary0to14
    {
        type            processor;
        inGroups        1(processor);
        nFaces          131;
        startFace       34983;
        matchTolerance  0.0001;
        transform       unknown;
        myProcNo        0;
        neighbProcNo    14;
    }
</pre><p>The decomposePar utility is a commonly used method to decompose domains and subsequently distribute the fields. The reconstructPar and reconstructParMesh utilities can be used to reconstruct a single domain from the processor sub-domains.</p>
<h1><a class="anchor" id="secDecomposeParDict"></a>
The decomposeParDict</h1>
<p>The <code>decomposeParDict</code> is required by decompose utilities and for any solvers or utilities running in parallel. It is normally located in the simulation <code>system</code> directory. The <code>-decomposeParDict name</code> command-line option can be used to specify an alternate file.</p>
<p>The <em>numberOfSubdomains</em> entry is mandatory: </p><pre class="fragment">    numberOfSubdomains  &lt;int&gt;;
</pre><p>The <em>method</em> entry is required for the decomposePar utility and specifies the decomposition method type: </p><pre class="fragment">    method  &lt;word&gt;;
</pre><p> The <em>method</em> entry is generally not required when running a simulation.</p>
<p>OpenFOAM offers a variety of decomposition methods and interfaces to external, third-party decomposition routines. The types of decomposition methods available will thus depend on your particular installation.</p>
<table class="OFTable">
<tr>
<th align="center"><b> Name </b> </th><th align="center"><b> Class</b>  </th></tr>
<tr>
<td><code>none</code>  </td><td><a class="el" href="classFoam_1_1noDecomp.html" title="A dummy decomposition method, selected as none.">Foam::noDecomp</a>  </td></tr>
<tr>
<td><code>manual</code>  </td><td><a class="el" href="classFoam_1_1manualDecomp.html" title="Decompose based on cell-to-processor association in a file.">Foam::manualDecomp</a>  </td></tr>
<tr>
<td><code>simple</code>  </td><td><a class="el" href="classFoam_1_1simpleGeomDecomp.html" title="Simple geometric decomposition, selectable as simple.">Foam::simpleGeomDecomp</a>  </td></tr>
<tr>
<td><code>hierarchical</code>  </td><td><a class="el" href="classFoam_1_1hierarchGeomDecomp.html" title="Does hierarchical decomposition of points, selectable as hierarchical.">Foam::hierarchGeomDecomp</a>  </td></tr>
<tr>
<td><code>kahip</code>  </td><td><a class="el" href="classFoam_1_1kahipDecomp.html" title="Domain decomposition using KaHIP http://algo2.iti.kit.edu/documents/kahip/.">Foam::kahipDecomp</a>  </td></tr>
<tr>
<td><code>metis</code>  </td><td><a class="el" href="classFoam_1_1metisDecomp.html" title="Metis domain decomposition.">Foam::metisDecomp</a>  </td></tr>
<tr>
<td><code>scotch</code>  </td><td><a class="el" href="classFoam_1_1scotchDecomp.html" title="Scotch domain decomposition.">Foam::scotchDecomp</a>  </td></tr>
<tr>
<td><code>structured</code>  </td><td><a class="el" href="classFoam_1_1structuredDecomp.html" title="Walk out decomposition of patch cells mesh - selectable as structured.">Foam::structuredDecomp</a>  </td></tr>
<tr>
<td><code>multiLevel</code>  </td><td><a class="el" href="classFoam_1_1multiLevelDecomp.html" title="Decompose given using consecutive application of decomposers.">Foam::multiLevelDecomp</a>  </td></tr>
</table>
<p>If a decomposition method requires any additional configuration controls, these are specified either within in a generic <code>coeffs</code> dictionary that or a method-specific version. For example,</p>
<pre class="fragment">    method  hierarchical;

    coeffs
    {
        n   (4 2 3);
    }

    // -----

    method  metis;

    metisCoeffs
    {
        method  k-way;
    }
</pre><p>For simplicity, the generic <code>coeffs</code> dictionary is generally preferrable. However, for some specific decomposition methods (eg, <a class="el" href="domainDecomposition.html#subsecMultiLevel">multiLevel</a>) only the method-specific coefficients dictionary is permitted.</p>
<h2><a class="anchor" id="subsecRegions"></a>
Multi-region</h2>
<p>When running multi-region simulations, it may be desirable to use different decomposition methods for one or more regions, or even to have fewer processors allocated to a particular region. If, for example, the multi-region simulation contains a large fluid region and a very small solid region, it can be advantageous to decompose the solid onto fewer processors.</p>
<p>The region-wise specification is contained in a <em>regions</em> subdictionary with decomposeParDict. For example,</p>
<pre class="fragment">    numberOfSubdomains  2048;
    method  metis;

    regions
    {
        heater
        {
            numberOfSubdomains  2;
            method  hierarchical;
            coeffs
            {
                n   (2 1 1);
            }
        }

        "*.solid"
        {
            numberOfSubdomains  16;
            method  scotch;
        }
    }
</pre><dl class="section note"><dt>Note</dt><dd>The top-level numberOfSubdomains remains mandatory, since this specifies the number of domains for the entire simulation. The individual regions may use the same number or fewer domains. The <em>numberOfSubdomains</em> entry within a region specification is only needed if the value differs.</dd></dl>
<h2><a class="anchor" id="subsecMultiLevel"></a>
Multi-level decomposition</h2>
<p>The <a class="el" href="classFoam_1_1multiLevelDecomp.html" title="Decompose given using consecutive application of decomposers.">Foam::multiLevelDecomp</a> decomposition provides a general means of successively decomposing with different methods. Each application of the decomposition is termed a level. For example,</p>
<pre class="fragment">    numberOfSubdomains  2048;
    method  multiLevel;

    multiLevelCoeffs
    {
        nodes
        {
            numberOfSubdomains 128;
            method  hierarchical;
            coeffs
            {
                n   (16 4 2);
            }
        }
        cpus
        {
            numberOfSubdomains 2;
            method  scotch;
        }
        cores
        {
            numberOfSubdomains 8;
            method  metis;
        }
    }
</pre><p>For cases where the same method is applied at each level, this can also be conveniently written in a much shorter form: </p><pre class="fragment">    numberOfSubdomains  2048;
    method  multiLevel;

    multiLevelCoeffs
    {
        method  scotch
        domains (128 2 8);
    }
</pre><p>When the specified <em>domains</em> is smaller than <em>numberOfSubdomains</em> but can be resolved as an integral multiple, this integral multiple is used as the first level. This can make it easier to manage when changing the number of domains for the simulation. For example, </p><pre class="fragment">    numberOfSubdomains  1024;
    method  multiLevel;

    multiLevelCoeffs
    {
        method  scotch
        domains (2 8);    //&lt; inferred as   domains (64 2 8);
    }
</pre><h2><a class="anchor" id="subsecConstraints"></a>
Constraints</h2>
<pre class="fragment">    constraints
    {
        // Keep owner and neighbour of baffles on same processor
        // (ie, keep it detectable as a baffle).
        // Baffles are two boundary face sharing the same points
        baffles
        {
            type    preserveBaffles;
            enabled true;
        }

        // Keep owner and neighbour on same processor for faces in zones
        faces
        {
            type    preserveFaceZones;
            zones   (".*");
            enabled true;
        }

        // Keep owner and neighbour on same processor for faces in patches
        // (only makes sense for cyclic patches. Not suitable for e.g.
        // cyclicAMI since these are not coupled on the patch level.
        // Use singleProcessorFaceSets for those.
        patches
        {
            type    preservePatches;
            patches (".*");
            enabled true;
        }

        // Keep all of faceSet on a single processor. This puts all cells
        // connected with a point, edge or face on the same processor.
        // (just having face connected cells might not guarantee a balanced
        // decomposition)
        // The processor can be -1 (the decompositionMethod chooses the
        // processor for a good load balance) or explicitly provided (upsets
        // balance)
        processors
        {
            type    singleProcessorFaceSets;
            sets    ((f1 -1));
            enabled true;
        }

        // Decompose cells such that all cell originating from single cell
        // end up on same processor
        refinement
        {
            type    refinementHistory;
            enabled true;
        }

        // Prevent decomposition splitting of the geometric regions
        // Uses any topoSetFaceSource for selecting the constrained faces
        geometric
        {
            type    geometric;

            grow    false;

            selection
            {
                box1
                {
                    source  box;
                    min     (-10 -10 -10);
                    max     (1 1 1);
                }

                ball1
                {
                    source  sphere;
                    origin  (-2 -2 1);
                    radius  1;
                }

                arbitrary
                {
                    source  surface;
                    surfaceType  triSurfaceMesh;
                    surfaceName  blob.obj;
                }
            }
        }
    }
</pre> </div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- HTML footer for doxygen 1.8.11-->
<!-- start footer part -->
<hr class="footer"/>
  <address class="footer">
    <small>
      <p>
        Copyright&nbsp;&copy;&nbsp;2011-2018&nbsp;
        <a href="http://www.openfoam.com">OpenFOAM</a>
        |
        OPENFOAM&reg; is a registered
        <a href="http://www.openfoam.com/legal/trademark-policy.php">trademark
        </a> of OpenCFD Ltd.
      </p>
      <p>
        Generated by &#160;<a href="http://www.doxygen.org/index.html">
        <img class="footer" src="doxygen.png" alt="doxygen"/>
        </a> 1.9.8
      </p>
    </small>
  </address>
<!-- BEGIN MATHJAX-->
<!-- END MATHJAX-->
</body>
</html>
